import { ProjectData } from '@/app/projects/new/page';

/**
 * Generates documentation for a project and stores in browser localStorage
 * This is a client-side alternative when file system is not available
 * @returns boolean indicating success or failure
 */
export const generateAndStoreClientDocs = (projectData: ProjectData): boolean => {
  try {
    // Format date for the progress tracker
    const createdDate = new Date().toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    });

    // Create documentation content
    const packagesList = projectData.selectedPackages.length > 0
      ? projectData.selectedPackages.map(pkg => `- ${pkg}`).join('\n')
      : '- No packages selected';

    // PRD content
    const prd = `# Product Requirements Document - ${projectData.name}

## Overview

${projectData.description}

## Project Details

- **Project Type:** ${projectData.type}
- **Framework:** ${projectData.framework}
- **Template:** ${projectData.template}

## Tech Stack

### Core Technologies
- **Frontend Framework:** ${projectData.framework}
- **Language:** TypeScript
- **Styling:** Tailwind CSS
- **UI Components:** shadcn/ui
- **State Management:** Zustand
- **Backend Integration:** Supabase

### Selected Packages
${packagesList}

## Requirements

### Functional Requirements

1. **Core Functionality**
   - Implement the main features of ${projectData.name}
   - Support user authentication and authorization
   - Create responsive, mobile-friendly interfaces

2. **User Experience**
   - Design intuitive navigation and information architecture
   - Ensure accessibility compliance
   - Optimize for performance across devices

3. **Data Management**
   - Implement efficient data fetching and caching
   - Set up proper error handling
   - Create data validation schema

### Non-Functional Requirements

1. **Performance**
   - Page load time < 2 seconds
   - Time to interactive < 3 seconds
   - Optimize asset loading

2. **Security**
   - Implement secure authentication
   - Protect against common vulnerabilities (XSS, CSRF)
   - Follow secure coding practices

3. **Scalability**
   - Design the system to handle increasing load
   - Implement performance monitoring

## Implementation Timeline

1. **Week 1: Setup & Core Architecture**
   - Initialize project structure
   - Set up authentication flows
   - Implement basic components

2. **Week 2-3: Core Feature Development**
   - Implement main application features
   - Create reusable components
   - Set up state management

3. **Week 4: Testing & Refinement**
   - Add unit and integration tests
   - Optimize performance
   - Implement feedback

4. **Week 5: Deployment & Documentation**
   - Prepare deployment pipeline
   - Finalize documentation
   - Launch MVP

## Success Metrics

- Successful deployment with no critical issues
- Core features functioning as expected
- User experience matching design requirements
- Performance metrics within target ranges

---
*This PRD was auto-generated by CursorCraft*`;

    // Code Style content
    const codeStyle = `# Code Style Guidelines - ${projectData.name}

This document outlines the coding standards and best practices for the ${projectData.name} project built with ${projectData.framework}.

## General Principles

- Write clean, readable, and maintainable code
- Follow TypeScript best practices
- Use consistent naming and formatting
- Write self-documenting code with descriptive names
- Add comments for complex logic only

## TypeScript Guidelines

- Use strict type checking with \`strict: true\` in tsconfig
- Avoid using \`any\` type whenever possible
- Use interface for object shapes that will be used across the codebase
- Use type for simpler, single-use object types
- Use proper type annotations for function parameters and return types
- Use type inference where it makes code cleaner and type is obvious

## Folder Structure

- Use the standard Next.js App Router structure
- Keep related files together within feature-based directories
- Place reusable UI components in \`components/\`
- Place utility functions and services in \`lib/\`
- Organize styles in \`styles/\`
- Keep documentation in \`docs/\`

## Component Guidelines

### Naming Conventions

- Use PascalCase for component names
- Use descriptive, noun-based names for components
- Use camelCase for variables, functions, and instances

### Component Structure

- Use functional components with hooks
- Put each component in its own file
- Export components as named exports
- For complex components, separate logic, state management, and UI
- Use JSDoc comments for component documentation

### Props

- Define prop interfaces at the top of the file
- Use destructuring for props
- Provide default values for optional props

## CSS Guidelines

- Follow a consistent naming convention for CSS classes
- Use Tailwind CSS utility classes primarily
- Prefer composition over complex styling
- Use CSS variables for theming and customization

## State Management

- Use Zustand for global state management
- Keep state logic separate from UI components
- Use local state (useState) for component-specific state
- Use reducers for complex state logic

## Testing

- Write unit tests for utility functions
- Write component tests for UI components
- Test edge cases and error states
- Use mock data for tests

## Git Practices

- Write clear, concise commit messages
- Reference issue numbers in commit messages
- Keep commits focused on a single change
- Create feature branches for new features
- Use pull requests for code reviews

## Framework-Specific Guidelines

### ${projectData.framework} Best Practices

- Follow the official documentation for ${projectData.framework}
- Use built-in features and optimizations provided by the framework
- Implement proper error boundaries and fallbacks
- Follow the framework's recommended patterns for data fetching and state management

## ESLint and Prettier Configuration

- Use ESLint for static code analysis
- Use Prettier for code formatting
- Enforce consistent code style across the project
- Fix linting errors before committing

---
*This Code Style Guide was auto-generated by CursorCraft*`;

    // Cursor AI Rules content
    const cursorRules = `# Cursor AI Rules - ${projectData.name}

This document provides configuration and guidelines for using AI assistants with the ${projectData.name} project.

## Project Overview

- **Project Name:** ${projectData.name}
- **Description:** ${projectData.description}
- **Framework:** ${projectData.framework}
- **Type:** ${projectData.type}

## AI Assistant Configuration

### Project Understanding

When working with this project, AI assistants should:

- Understand that this is a ${projectData.type} project built with ${projectData.framework}
- Be aware of the selected dependencies and libraries
- Follow the established code style and patterns in the project
- Respect the application architecture and component structure

### Code Generation Guidelines

When generating code for this project, follow these guidelines:

1. **Framework Consistency**
   - Generate code that follows ${projectData.framework} best practices
   - Use TypeScript for all code
   - Follow the existing project patterns and conventions

2. **Component Guidelines**
   - Create functional components with proper TypeScript typing
   - Follow the component structure used in the project
   - Use proper imports from the designated libraries
   - Follow the established naming conventions

3. **Styling Approach**
   - Use Tailwind CSS for styling
   - Follow the project's design system and UI component library (shadcn/ui)
   - Maintain consistency with existing UI components

4. **State Management**
   - Use Zustand for global state management
   - Follow the established patterns for managing application state
   - Keep state logic separate from UI components

### Documentation Generation

When generating documentation:

1. **Code Comments**
   - Add JSDoc comments for components, functions, and types
   - Document complex logic and algorithms
   - Document props, return values, and side effects

2. **Markdown Documentation**
   - Create clear, concise documentation
   - Use proper Markdown formatting
   - Structure documentation with headings, lists, and code blocks

## Project-Specific Instructions

### Feature Implementation

When implementing new features, ensure:

1. The feature aligns with the project requirements
2. The implementation follows the established patterns
3. The code is properly tested
4. The documentation is updated

### Troubleshooting Common Issues

For common issues, AI should:

1. Check for type errors and mismatches
2. Verify library imports and usage
3. Ensure proper state management
4. Check for styling conflicts
5. Validate data fetching and handling

## Performance Considerations

- Optimize component rendering
- Minimize re-renders and unnecessary computations
- Follow best practices for data fetching and caching
- Implement proper code splitting and lazy loading

---
*These Cursor AI Rules were auto-generated by CursorCraft*`;

    // Progress Tracker content
    const progressTracker = `# Progress Tracker - ${projectData.name}

## Project Overview

- **Project Name:** ${projectData.name}
- **Description:** ${projectData.description}
- **Framework:** ${projectData.framework}
- **Type:** ${projectData.type}
- **Created On:** ${createdDate}

## Project Milestones

| Milestone | Status | Target Date | Completion Date | Notes |
|-----------|--------|-------------|----------------|-------|
| Project Setup | Not Started | | | Initial setup and configuration |
| Core Architecture | Not Started | | | Basic framework and structure |
| UI Components | Not Started | | | Build reusable UI components |
| Data Layer | Not Started | | | API integration and state management |
| Feature Development | Not Started | | | Implement main features |
| Testing | Not Started | | | Unit and integration tests |
| Documentation | Not Started | | | Technical and user documentation |
| Deployment | Not Started | | | Production deployment |

## Tasks Breakdown

### Project Setup
- [ ] Initialize project with ${projectData.framework}
- [ ] Set up TypeScript configuration
- [ ] Configure ESLint and Prettier
- [ ] Set up Tailwind CSS
- [ ] Install required dependencies
- [ ] Create initial project structure

### Core Architecture
- [ ] Create routing structure
- [ ] Set up authentication system
- [ ] Configure API client
- [ ] Set up state management with Zustand
- [ ] Define data models and types

### UI Components
- [ ] Create layout components
- [ ] Build form components
- [ ] Implement navigation elements
- [ ] Design and build page templates
- [ ] Create loading and error states

### Data Layer
- [ ] Implement API services
- [ ] Create data fetching hooks
- [ ] Set up caching strategy
- [ ] Implement error handling
- [ ] Create data validation

### Feature Development
- [ ] Implement feature 1 (TBD)
- [ ] Implement feature 2 (TBD)
- [ ] Implement feature 3 (TBD)
- [ ] Add responsive design
- [ ] Implement analytics

### Testing
- [ ] Write unit tests
- [ ] Create integration tests
- [ ] Perform accessibility testing
- [ ] Conduct performance testing
- [ ] Fix identified issues

### Documentation
- [ ] Create README
- [ ] Document component usage
- [ ] Create API documentation
- [ ] Write developer guide
- [ ] Create user documentation

### Deployment
- [ ] Set up CI/CD pipeline
- [ ] Configure production environment
- [ ] Perform security audit
- [ ] Deploy to staging
- [ ] Deploy to production

## Progress Updates

| Date | Update | Author |
|------|--------|--------|
| | | |

## Blockers and Issues

| Issue | Status | Priority | Assigned To | Notes |
|-------|--------|----------|-------------|-------|
| | | | | |

## Resources

- GitHub Repository: [Link to repository]
- Design Files: [Link to design files]
- API Documentation: [Link to API docs]
- Project Management: [Link to PM tool]

---
*This Progress Tracker was auto-generated by CursorCraft*`;

    // Store in localStorage for client-side access
    try {
      localStorage.setItem(`${projectData.name}_prd`, prd);
      localStorage.setItem(`${projectData.name}_code_style`, codeStyle);
      localStorage.setItem(`${projectData.name}_cursor_rules`, cursorRules);
      localStorage.setItem(`${projectData.name}_progress_tracker`, progressTracker);
      return true;
    } catch (storageError) {
      console.error('Error storing documents in localStorage:', storageError);
      // Continue execution even if localStorage fails
      return false;
    }
  } catch (error) {
    console.error('Error generating client-side docs:', error);
    return false;
  }
}; 